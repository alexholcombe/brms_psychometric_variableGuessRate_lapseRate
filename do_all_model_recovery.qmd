---
title: "Bayesian analysis of psychophysical data using brms"
format: html
---

TO-DO: add change in psychometric function based on number of targets

To get started, we load the required packages.

```{r}
#| warning: false 
#| output: false
library(tidyverse)
library(brms)
```


# Create simulated trials

In order to build and test our model in brms, we must first create a simulated data set that is similar to our actual experiment data. This allows us to confirm the brms model is working and successfully recovers the parameters we set before applying it to our real experimental data that has unknown parameter values. In the actual data, there will be many group-wise differences in location and scale parameters. The following simulated data only has explicit differences between the $\eta$ (location) of the two age groups (older vs younger).


```{r}
#| echo: true 
set.seed(999) #ensures reproducibility for testing

source("R/simulate_data.R") #Load my needed custom function
source("R/psychometric_function.R") #Load my needed custom function

numSubjects<- 50
trialsPerCondition<- 5
targetNumConds<- c(2,3)
#Array of speeds (not very realistic because mostly controlled by a staircase in actual experiment)
speeds<-seq(.02,1.8, length.out = 12) # trials at 12 different speeds between .02 and 1.8

trials <- generate_conditions_both_labs(numSubjects,trialsPerCondition,targetNumConds,speeds)
#includes obj_per_ring

```

Choose values for psychometric function for younger and older

```{r}
#| echo: true 
lapse <- 0.03
sigma <- 0.2
location_param_young <-0.91 
location_param_old   <-0.5
```

Using the psychometric function, simulate whether participant is correct on each trial or not, and 
add that to the simulated data, trials

```{r}
#| echo: true

data_simulated<- trials

#Add column for the probability of each trial being correct based on our psychometric function
#then use that to add column to generate if the subject got the trial correct
data_simulated <- data_simulated %>%
  mutate(
    chance_rate = 1/obj_per_ring,
    p_correct= ifelse(age_group == "younger",
                      psychometric_function(1/obj_per_ring,lapse,speed,location_param_young,sigma),
                      psychometric_function(1/obj_per_ring,lapse,speed,location_param_young,sigma)
                      ),
    correct = rbinom(n=length(p_correct), size=1, prob=p_correct)
  )
    
```    
    


#Convert these variables from vectors to factors
simdata <- simdata %>%
  mutate(
    gender = as_factor(gender),
    age_group = as_factor(age_group),
    lab = as_factor(lab),
    gender = as_factor(gender)
  ) 




# Setting up our Model in brms

Setting a model formula in brms allows the use of multilevel additive models, where there is a hierarchical structure in the data. But at this point we haven't made the model multi-level as we have been concentrating on the basics of brms.

The bf() function of brms allows the specification of a formula. The parameter can be defined by population effects, where the parameter's effect is fixed, or group level effects where the parameter varies with a variable such as age. The "family" argument is a description of the response distribution and link function that the model uses. For more detailed information on setting up a formula and the different arguments in BRMS see<https://paulbuerkner.com/brms/reference/brmsformula.html>

The model we used is based off our psychometric function used to generate the data mentioned previously. The only explicitly-coded difference in our simulated data is in the location parameter of older vs younger. Thus, in addition to the psychometric function, we allowed $\eta$ and $\log(\sigma)$ to vary by age group in the model. Because the psychometric function doesn't map onto a canonical link function, we use the non-linear estimation capability of brms rather than linear regression with a link function.

*Alex's note: Using the nonlinear option is also what allowed us to set a prior on the thresholds  $\eta$, because we could then parametrize the function in terms of the x-intercept, whereas with a link-function approach, we are stuck with the conventional parameterization of a line, which [has a term for the y-intercept but not the x-intercept](https://bsky.app/profile/did:plc:kynaetyuzsp46xejc6mzpjle/post/3lg5lpartzs2z) *

```{r}
model_formula <- bf(
  correct ~ chance_rate + (1-chance_rate - lapse*(1-chance_rate))*Phi(-(speed-eta)/exp(logsigma)), 
  eta ~ age_group, 
  lapse ~ 1, #constant/intercept only
  logsigma ~ age_group,
  family = bernoulli(link="identity"), #Otherwise the default link 'logit' would be applied
  nl = TRUE #non-linear model
)
```

# Set priors

See [visualize_and_select_priors.html](visualize_and_select_priors.html) for some motivation and visualisation.

```{r}

my_priors <- c(
  brms::set_prior("beta(2,33.33)", class = "b", nlpar = "lapse", lb = 0, ub = 1),
  brms::set_prior("uniform(0, 2.5)", class = "b", nlpar = "eta", lb = 0, ub = 2.5),
  brms::set_prior("uniform(-3, 1.6)", class = "b", nlpar = "logsigma", lb = -2, ub = 1.6) 
)

```

# Fitting Model to Simulated Data

Fitting the model gives an estimation of the average parameter value of the participants. The brm() function is used to fit the model based on the given formula, data and priors. Other arguments of brm can adjust the model fitting in various ways, for more information on each of the arguments see <https://paulbuerkner.com/brms/reference/brm.html>

```{r}

fit <- brm(
  model_formula,
  data = simdata,
  prior = prior1,
  silent = 0, #prints more detailed messages (helps debug)
  init = 0, #starting at
  chains = 4, # the more chains, the greater convergence in the model
  cores = 4, #how many parallel processes, speeds up model 
  iter = 2000, #default number of iterations 
  threads = threading(2) #how many cores work per chain
)

summary(fit)
```

The fit converged with no errors!! :grinning: (this doesn't always happen, when for example we use more complicated models)

In the above output, "Error Est" for the intercepts is the average of each participant's estimated eta, lapse, logsigma. The eta_age \_groupyounger represents the average eta advantage for the younger age group. The above output has estimated the difference to be 0.38 which is close to the 0.41 difference that was used to generate the data. The estimated difference in logsigma is small, not far off the 0 difference used to generate the data.

The fitted model's estimated of the parameters are close to those used to generate the simulated data, meaning the model recovery was a success!!

# Model Improvements

Although we have learned a lot and made significant progress over the course of 6 weeks, there is still work to be done and errors we are running into in our model recovery. In particular, when we alter the simulated data and model fit to include group-level effects for variables such as number of targets or objects per ring, the estimations are very inaccurate. We also have yet to test changes to group level values of sigma and are unsure whether the lapse rate may have a group effect for various conditions or population groups.

Another key area to look into is the brms syntax and fitting for nested variables to create a multilevel model. brms allows nesting of variables using parameter \* (1 \| nested group) \*, but have not yet researched this or added it to our model.

# References

Holcombe, Alex O, and Wei-ying Chen. 2013. “Splitting Attention Reduces Temporal Resolution from 7 Hz for Tracking One Object to \<\<3 Hz When Tracking Three.” *Journal of Vision* 13 (1): 1–19. <https://doi.org/10.1167/13.1.12>.

Holcombe, A O, and Chen, W-Y. (2020 unpublished manuscript). “The Speed Limit on Attentional Tracking.” *Journal of Vision*.

Roudaia, E, & Faubert, J. 2017. "Different effects of aging and gender on the temporal resolution in attentional tracking." *Journal of Vision*, 17 (11): 1-1. <https://doi.org/10.1167/17.11.1>

Schütt, Heiko H., Stefan Harmeling, Jakob H. Macke, and Felix A. Wichmann. 2016. "Painfree and accurate Bayesian estimation of psychometric functions for (potentially) overdispersed data." *Vision research* 122: 105-123.

# Acknowledgements

We would like to extend a special thanks to our supervisor Professor Alex Holcombe for his guidance and support on the project. Additionally, we would like to extend thanks to Stella Katsoulis and Sarah Cronje who ran through the experiment with us, allowing us to have a fundamental understanding of what the data was actually representing. We acknowledge the use of Microsoft Copilot in assisting debugging our code and figuring out various RStudio functions and syntax.

--- Vince Tafea and Rachel K. Wong