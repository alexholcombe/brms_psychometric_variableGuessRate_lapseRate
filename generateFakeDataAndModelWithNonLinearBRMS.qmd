## Load R libraries

This code initially based on <https://discourse.mc-stan.org/t/fitting-lapsing-psychometric-functions-with-brms/5762/2> .

```{r}
library(tidyverse)
library(ggdist)
library(brms)
library(cowplot)

```

## Generate a fake dataset based on the cumulative normal

because I think can use probit (inverse of the cumulative normal) to recover the parameters, with true location parameterization

```{r}
#possibly need to make new locations and scales per condition combination
location_parameter <- 1 
scale_parameter <- 0.1

conditionsAndIVs <- 
  tidyr::expand_grid(
    speed = seq(.02,1.8, length.out = 11), #changed min and max speed to match our data
    objects = 5,
    rep = seq(1, 100),
    subj = seq(1, numSs)
  )

fakedataProbit<- conditionsAndIVs
fakedataProbit<- fakedataProbit %>% mutate(
                                    chanceRate = 1/objects )
fakedataProbit$chanceRate <- 0 #TEMP
  
#create a new column for the response
#Cumulative gaussian: pnorm(q, mean, sd)

fakedataProbit<- fakedataProbit %>% mutate(
  probabilityCorrect = chanceRate + (1-chanceRate-lapse)*(1-pnorm(speed, mean = location_parameter, sd = scale_parameter))
)

#Generate binary responses
fakedataProbit<- fakedataProbit %>% mutate(
          correct = rbinom(n=length(probabilityCorrect), size = 1, prob = probabilityCorrect)
         )
#Use ascending for now
fakedataProbit$speed <- fakedataProbit$speed * -1

```

## Plot data

```{r}
#| echo: false
ggplot(fakedataProbit, aes(x=speed,y=correct)) + 
  geom_point() +
  stat_summary( fun="mean", geom="point" ,color="blue") +
  facet_wrap(.~subj)
```

## Set up the probit model

Example simple probit regression at https://www.bwilden.com/posts/probit-probit/

